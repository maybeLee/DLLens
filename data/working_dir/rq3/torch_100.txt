torch.resolve_conj(input)
torch.atan2(input, other, *, out=None)
torch.Tensor.matrix_exp(input)
torch.subtract(input, other, *, alpha=1, out=None)
torch.addmm(input, mat1, mat2, *, beta=1, alpha=1, out=None)
torch.Tensor.any(input, dim=None, keepdim=False)
torch.Tensor.logsumexp(input, dim, keepdim=False)
torch.from_numpy(ndarray)
torch.special.i1e(input, *, out=None)
torch.nn.functional.logsigmoid(input)
torch.logsumexp(input, dim, keepdim=False, *, out=None)
torch.dequantize(tensor)
torch.Tensor.vdot(input, other)
torch.Tensor.bitwise_and(input, other)
torch.Tensor.erfc(input)
torch.Tensor.eq(input, other)
torch.bitwise_right_shift(input, other, *, out=None)
torch.Tensor.true_divide(input, value)
torch.ceil(input, *, out=None)
torch.Tensor.floor_divide_(input, value)
torch.Tensor.erf_(input)
torch.isin(elements, test_elements, *, assume_unique=False, invert=False)
torch.min(input, dim, keepdim=False, *, out=None)
torch.div(input, other, *, rounding_mode=None, out=None)
torch.remainder(input, other, *, out=None)
torch.Tensor.sub_(input, other, *, alpha=1)
torch.Tensor.addmm_(input, mat1, mat2, *, beta=1, alpha=1)
torch.full_like(input, fill_value, *, dtype=None, layout=torch.strided, device=None, requires_grad=False, memory_format=torch.preserve_format)
torch.kron(input, other, *, out=None)
torch.Tensor.abs(input)
torch.Tensor.view_as(input, other)
torch.isnan(input)
torch.Tensor.item(input)
torch.Tensor.bitwise_right_shift_(input, other)
torch.nansum(input, dim, keepdim=False, *, dtype=None)
torch.Tensor.conj(input)
torch.Tensor.msort(input)
torch.lt(input, other, *, out=None)
torch.Tensor.diagonal(input, offset=0, dim1=0, dim2=1)
torch.sum(input, dim, keepdim=False, *, dtype=None)
torch.nn.functional.prelu(input, weight)
torch.atleast_1d(*tensors)
torch.isneginf(input, *, out=None)
torch.logical_not(input, *, out=None)
torch.tile(input, dims)
torch.searchsorted(sorted_sequence, values, *, out_int32=False, right=False, out=None)
torch.Tensor.triu_(input, diagonal=0)
torch.nn.functional.relu_(input)
torch.Tensor.broadcast_to(input, shape)
torch.resolve_neg(input)
torch.bucketize(input, boundaries, *, out_int32=False, right=False, out=None)
torch.Tensor.bitwise_not_(input)
torch.nn.functional.softsign(input)
torch.special.gammaincc(input, other, *, out=None)
torch.Tensor.type(input, dtype=None, non_blocking=False, **kwargs)
torch.maximum(input, other, *, out=None)
torch.all(input, dim, keepdim=False, *, out=None)
torch.Tensor.rsqrt(input)
torch.diagonal(input, offset=0, dim1=0, dim2=1)
torch.Tensor.addmv(input, mat, vec, *, beta=1, alpha=1)
torch.polar(abs, angle, *, out=None)
torch.fix(input, *, out=None)
torch.nn.functional.max_unpool1d(input, indices, kernel_size, stride=None, padding=0, output_size=None)
torch.baddbmm(input, batch1, batch2, *, beta=1, alpha=1, out=None)
torch.nn.init.zeros_(tensor)
torch.nn.functional.threshold(input, threshold, value, inplace=False)
torch.linalg.eigvalsh(A, UPLO='L', *, out=None)
torch.Tensor.index_select(input, dim, index)
torch.lerp(input, end, weight, *, out=None)
torch.concat(tensors, dim=0, *, out=None)
torch.Tensor.swapaxes(input, axis0, axis1)
torch.Tensor.tan_(input)
torch.nn.functional.leaky_relu(input, negative_slope=0.01, inplace=False)
torch.addcdiv(input, tensor1, tensor2, *, value=1, out=None)
torch.Tensor.fliplr(input)
torch.ger(input, vec2, *, out=None)
torch.Tensor.detach_(input, )
torch.Tensor.dot(input, other)
torch.special.erf(input, *, out=None)
torch.expm1(input, *, out=None)
torch.Tensor.is_floating_point(input)
torch.Tensor.sinc_(input)
torch.Tensor.div(input, value, *, rounding_mode=None)
torch.Tensor.minimum(input, other)
torch.Tensor.not_equal(input, other)
torch.max(input, dim, keepdim=False, *, out=None)
torch.var(input, dim, unbiased, keepdim=False, *, out=None)
torch.special.i1(input, *, out=None)
torch.Tensor.erfinv(input)
torch.Tensor.bitwise_or(input, other)
torch.Tensor.not_equal_(input, other)
torch.special.logit(input, eps=None, *, out=None)
torch.Tensor.moveaxis(input, source, destination)
torch.Tensor.squeeze(input, dim=None)
torch.nn.functional.avg_pool1d(input, kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True)
torch.where(condition, x, y)
torch.Tensor.greater(input, other)
torch.block_diag(*tensors)
torch.Tensor.tanh(input)
torch.tril(input, diagonal=0, *, out=None)